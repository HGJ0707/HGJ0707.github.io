import{_ as d,r as a,o as _,c as n,a as o,b as c,w as r,d as e,e as s}from"./app-98f0cb17.js";const l="/document/images/javascript/9-1-原型和原型链.png",p={},i=o("h1",{id:"原型和原型链",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#原型和原型链","aria-hidden":"true"},"#"),e(" 原型和原型链")],-1),u={class:"table-of-contents"},h=s('<p><img src="'+l+'" alt="img"></p><h2 id="proto" tabindex="-1"><a class="header-anchor" href="#proto" aria-hidden="true">#</a> <code>__proto__</code></h2><p><code>__proto__</code> 是每一个 JS 对象（除了 <code>null</code>）都有的一个属性，指向该对象的原型。</p><p>当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会通过它的 <code>__proto__</code> 搜寻该对象的原型，以及原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾( <code>null</code> );</p><p>通过 <code>__proto__</code> 属性将对象连接起来的这条链路就是原型链。</p><h2 id="prototype" tabindex="-1"><a class="header-anchor" href="#prototype" aria-hidden="true">#</a> prototype</h2><p><code>prototype</code> 是函数所独有的，指向函数的原型对象。</p><ul><li>作用：包含可以由特定类型的所有实例共享的属性和方法。也就是让该函数所实例化的对象们都可以找到公用的属性和方法。</li><li>任何函数在创建的时候，其实会默认同时创建该函数的 <code>prototype</code> 对象。</li><li>因为函数的本质也是一个对象，所以也拥有 <code>__proto__</code> 和 <code>constructor</code> 属性。</li></ul><h2 id="constructor" tabindex="-1"><a class="header-anchor" href="#constructor" aria-hidden="true">#</a> constructor</h2><p><code>constructor</code> 是对象才有，指向该对象的构造函数。</p><p>所有函数和对象最终都是由 <code>Function</code> 构造函数得来，所以 <code>constructor</code> 属性的终点就是 <code>Function</code> 这个函数；</p>',11);function f(m,x){const t=a("router-link");return _(),n("div",null,[i,o("nav",u,[o("ul",null,[o("li",null,[c(t,{to:"#proto"},{default:r(()=>[e("__proto__")]),_:1})]),o("li",null,[c(t,{to:"#prototype"},{default:r(()=>[e("prototype")]),_:1})]),o("li",null,[c(t,{to:"#constructor"},{default:r(()=>[e("constructor")]),_:1})])])]),h])}const b=d(p,[["render",f],["__file","9-原型和原型链.html.vue"]]);export{b as default};
