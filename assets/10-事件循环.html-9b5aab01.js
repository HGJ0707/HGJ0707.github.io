import{_ as e,o as i,c as a,a as n}from"./app-eb5bb617.js";const s="/document/images/javascript/10-1-eventLoop.jpg",c={},l=n('<h1 id="事件循环" tabindex="-1"><a class="header-anchor" href="#事件循环" aria-hidden="true">#</a> 事件循环</h1><p>JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。</p><p>JavaScript 的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p><div class="custom-container tip"><p class="custom-container-title">提示</p><p><strong>常见微任务</strong>：Promise.then()、MutationObserver、await、process.nextTick（Node.js）等；</p><p><strong>常见宏任务</strong>：script（整体代码）、setTimeout、setInterval、I/O 操作、UI 渲染、setImmediate（Node.js）等。</p></div><h2 id="浏览器中的事件循环" tabindex="-1"><a class="header-anchor" href="#浏览器中的事件循环" aria-hidden="true">#</a> 浏览器中的事件循环</h2><p><img src="'+s+`" alt="img"></p><ol><li><p>首先执行执行栈中的代码，遇到异步任务则会放到任务队列中去；</p></li><li><p>执行栈中的任务都执行完后，查看任务队列中的异步任务是否到了执行的时机；</p></li><li><p>任务队列分为两种：微任务队列和宏任务队列。优先获取微任务队列中的任务放到执行栈中执行，再取宏任务进行执行；</p></li><li><p>任务队列取出来的任务放到执行栈中执行又会遇到异步任务，于是又回到第一步中，形成事件循环；</p></li></ol><h2 id="node-js-中的事件循环" tabindex="-1"><a class="header-anchor" href="#node-js-中的事件循环" aria-hidden="true">#</a> Node.js 中的事件循环</h2><h2 id="node-事件循环模型" tabindex="-1"><a class="header-anchor" href="#node-事件循环模型" aria-hidden="true">#</a> node 事件循环模型</h2><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>   ┌───────────────────────┐
┌─<span class="token operator">&gt;</span>│        timers         │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     <span class="token constant">I</span><span class="token operator">/</span><span class="token constant">O</span> callbacks     │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     idle<span class="token punctuation">,</span> prepare     │
│  └──────────┬────────────┘      ┌───────────────┐
│  ┌──────────┴────────────┐      │   incoming<span class="token operator">:</span>   │
│  │         poll          │<span class="token operator">&lt;</span>─────┤  connections<span class="token punctuation">,</span> │
│  └──────────┬────────────┘      │   data<span class="token punctuation">,</span> etc<span class="token punctuation">.</span>  │
│  ┌──────────┴────────────┐      └───────────────┘
│  │        check          │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
└──┤    close callbacks    │
   └───────────────────────┘
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>每个阶段都有一个<strong>FIFO</strong>的回调队列（queue）要执行。当 event loop 进入某个阶段后，会执行该阶段特定的（任意）操作，然后才会执行这个阶段的队列里的回调。当队列被执行完，或者执行的回调数量达到上限后，event loop 会进入下个阶段。</p><h3 id="事件循环各阶段描述" tabindex="-1"><a class="header-anchor" href="#事件循环各阶段描述" aria-hidden="true">#</a> 事件循环各阶段描述</h3><ul><li><p><code>timers</code> 阶段: 这个阶段执行（ <code>setTimeout</code>、<code>setInterval</code> ）的回调，该阶段新创建的 <code>setTimeout</code>、<code>setInterval</code> 会继续放在下一个轮回循环阶段执行</p></li><li><p><code>I/O callbacks</code> 阶段: 执行一些系统操作的回调(比如网络通信的错误回调)；</p></li><li><p><code>idle, prepare</code> 阶段: 仅 node 内部使用;</p></li><li><p><code>poll</code> 阶段: 获取新的 I/O 事件, 适当的条件下 node 将阻塞在这里（比如：文件读取操作，http 请求 回调） 底层代码在 <code>poll</code> 阶段执行的时候，会传入一个 timeout 超时时间，timeout 超时时间到了，则退出 <code>poll</code> 阶段，执行下一个阶段。</p></li><li><p><code>check</code> 阶段: 执行 <code>setImmediate()</code> 设定的 <code>callbacks</code>;</p></li><li><p><code>close callbacks</code> 阶段: 比如 <code>socket.on(‘close’, callback)</code>的 <code>callback</code> 会在这个阶段执行。</p></li></ul><h3 id="事件循环执行过程" tabindex="-1"><a class="header-anchor" href="#事件循环执行过程" aria-hidden="true">#</a> 事件循环执行过程</h3><ul><li><p>node 的初始化，初始化 node 环境，执行输入代码</p></li><li><p>先执行同步任务、再执行 <code>process.nextTick</code> 、微任务；</p></li></ul><div class="custom-container tip"><p class="custom-container-title">提示</p><p>在事件循环的每一个子阶段退出之前都会执行：<code>process.nextTick</code>，微任务。（ <code>process.nextTick</code> 先于微任务执行）</p></div><ul><li><p>进入 event-loop</p></li><li><p>进入 timers 阶段（ <code>setTimeout</code>、<code>setInterval</code> ）</p></li><li><p>进入 IO callbacks 阶段</p></li><li><p>进入 idle，prepare 阶段</p></li><li><p>进入 poll 阶段</p></li><li><p>进入 check 阶段（ <code>setImmediate</code> ）</p></li><li><p>进入 closing 阶段</p></li><li><p>检查是否有活跃的 handles（定时器、IO 等事件句柄）。如果有，继续下一轮循环。如果没有，结束事件循环，退出程序。</p></li></ul><p>https://blog.csdn.net/weixin_44730897/article/details/128135836</p>`,18),o=[l];function d(t,p){return i(),a("div",null,o)}const u=e(c,[["render",d],["__file","10-事件循环.html.vue"]]);export{u as default};
