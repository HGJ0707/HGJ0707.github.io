import{_ as r,r as d,o as i,c,a,b as s,w as t,d as e,e as o}from"./app-8b4ed804.js";const h={},l=a("h1",{id:"变量声明",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#变量声明","aria-hidden":"true"},"#"),e(" 变量声明")],-1),p={class:"table-of-contents"},u=o(`<h2 id="三种声明方式" tabindex="-1"><a class="header-anchor" href="#三种声明方式" aria-hidden="true">#</a> 三种声明方式</h2><h4 id="var" tabindex="-1"><a class="header-anchor" href="#var" aria-hidden="true">#</a> var</h4><p>声明一个<strong>变量</strong>，初始值为undefined，可选初始化一个值。</p><h4 id="let" tabindex="-1"><a class="header-anchor" href="#let" aria-hidden="true">#</a> let</h4><p>声明一个块作用域的<strong>局部变量</strong>，初始值为undefined，可选初始化一个值。</p><h4 id="const" tabindex="-1"><a class="header-anchor" href="#const" aria-hidden="true">#</a> const</h4><p>声明一个块作用域的只读<strong>常量</strong>。常量不可以通过重新赋值改变其值，也不可以在代码运行时重新声明。它必须被初始化为某个值。</p><h2 id="变量作用域" tabindex="-1"><a class="header-anchor" href="#变量作用域" aria-hidden="true">#</a> 变量作用域</h2><h4 id="全局变量" tabindex="-1"><a class="header-anchor" href="#全局变量" aria-hidden="true">#</a> 全局变量</h4><p>在函数之外声明的变量，叫做<strong>全局变量</strong>，因为它可被当前文档中的任何其他代码所访问。</p><h4 id="局部变量" tabindex="-1"><a class="header-anchor" href="#局部变量" aria-hidden="true">#</a> 局部变量</h4><p>在函数内部声明的变量，叫做<strong>局部变量</strong>，因为它只能在当前函数的内部访问。</p><h2 id="变量提升" tabindex="-1"><a class="header-anchor" href="#变量提升" aria-hidden="true">#</a> 变量提升</h2><p>JavaScript 可以先使用变量稍后再声明变量而不会引发异常。这一概念称为变量提升；JavaScript 变量感觉上是被“提升”或移到了函数或语句的最前面。</p><p>提升后的变量将返回 undefined 值。因此在使用或引用某个变量之后进行声明和初始化操作，这个被提升的变量仍将返回 undefined 值。</p><h2 id="函数提升" tabindex="-1"><a class="header-anchor" href="#函数提升" aria-hidden="true">#</a> 函数提升</h2><p>对于函数来说，只有函数声明会被提升到顶部，而函数表达式不会被提升（报错）。</p><h4 id="函数声明" tabindex="-1"><a class="header-anchor" href="#函数声明" aria-hidden="true">#</a> 函数声明</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="函数表达式" tabindex="-1"><a class="header-anchor" href="#函数表达式" aria-hidden="true">#</a> 函数表达式</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">baz</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="对比-var-let-const" tabindex="-1"><a class="header-anchor" href="#对比-var-let-const" aria-hidden="true">#</a> 对比 var-let-const</h2><h4 id="变量提升-1" tabindex="-1"><a class="header-anchor" href="#变量提升-1" aria-hidden="true">#</a> 变量提升</h4><p>var声明的变量会进行变量提升，初始值为undefined；let和const同样会被提升变量到代码块的顶部但是不会被赋予初始值。在变量声明之前引用这个变量，将抛出引用错误（ReferenceError）。这个变量将从代码块一开始的时候就处在一个“暂时性死区”，直到这个变量被声明为止。</p><h4 id="作用域范围" tabindex="-1"><a class="header-anchor" href="#作用域范围" aria-hidden="true">#</a> 作用域范围</h4><p>var声明的范围是全局作用域；let声明的是块级作用域，用let声明的循环变量，会特殊处理，每次进入循环体，都会开启一个新的作用域，并且将循环变量绑定到该作用域(每次循环，使用的是一个全新的循环变量)。循环结束后，变量销毁；</p><h4 id="允许重复声明" tabindex="-1"><a class="header-anchor" href="#允许重复声明" aria-hidden="true">#</a> 允许重复声明</h4><p>var允许重复声明同一个变量，let和const同一个作用域重复声明会报错。</p><h4 id="全局对象" tabindex="-1"><a class="header-anchor" href="#全局对象" aria-hidden="true">#</a> 全局对象</h4><p>var声明的变量会挂载到全局对象window上，let和const不会。</p>`,30);function f(v,_){const n=d("router-link");return i(),c("div",null,[l,a("nav",p,[a("ul",null,[a("li",null,[s(n,{to:"#三种声明方式"},{default:t(()=>[e("三种声明方式")]),_:1})]),a("li",null,[s(n,{to:"#变量作用域"},{default:t(()=>[e("变量作用域")]),_:1})]),a("li",null,[s(n,{to:"#变量提升"},{default:t(()=>[e("变量提升")]),_:1})]),a("li",null,[s(n,{to:"#函数提升"},{default:t(()=>[e("函数提升")]),_:1})]),a("li",null,[s(n,{to:"#对比-var-let-const"},{default:t(()=>[e("对比 var-let-const")]),_:1})])])]),u])}const x=r(h,[["render",f],["__file","1-变量声明.html.vue"]]);export{x as default};
